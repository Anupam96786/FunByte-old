{% extends 'base.html' %}


{% block title %}
Tic-Tac-Toe
{% endblock %}

{% load static %}

{% block css %}
<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Nerko+One&display=swap" rel="stylesheet">
<style>
    #board {
        width: 100%;
        max-width: 60vh;
        display: flex;
        flex-wrap: wrap;
        font-size: 100px;
        margin-top: 20px;
        font-family: 'Nerko One', cursive;
    }

    .field {
        height: 20vh;
        width: 33.33333%;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #2a1e5c;
        border: none;
        border-radius: 0px;
        border-bottom: 3px solid #ffffff;
        border-right: 3px solid #ffffff;
        outline: none;
    }

    .field.win {
        background-color: #17d092;
        transition: background-color 2s;
    }

    .field.no-r {
        border-right: none;
    }

    .field.no-b {
        border-bottom: none;
    }

    .field p {
        margin: 0px;
    }

</style>
{% endblock %}

{% block page_header %}
Tic Tac Toe
{% endblock %}

{% block body %}

<!-- Row -->
<div class="row">
    <div class="card">
        <div class="card-body" style="padding-left: 0px; padding-right: 0px;">
            <div class="col-md-12 col-lg-4 mx-auto" style="min-width: fit-content; max-width: 60vh;">
                <div class="card" style="background-color: #2a1e5c;" id="gamecard">
                    <div class="card-header">
                        <h3 class="card-title mx-auto"
                            style="font-size: 60px; font-family: 'Nerko One', cursive; color: #dbdfac;">Play</h3>
                        <div class="d-md-flex" id="fulltable">
                            <a href="#" class="nav-link icon full-screen-link">
                                <i class="fe fe-minimize"></i>
                            </a>
                        </div>
                    </div>
                    <div class="card-body mx-auto"
                        style="width: 100%; max-width: 60vh; padding: 0px; padding-bottom: 24px;">
                        <div class="mx-auto">
                            <div style="width: fit-content; display: inline; float: left; padding-left: 5px;">
                                <h2
                                    style="font-family: 'Nerko One', cursive; color: #dbdfac; width: fit-content; display: inline;">
                                    Max Score :
                                </h2>
                                <h2 style="font-family: 'Nerko One', cursive; color: #dbdfac; width: fit-content; display: inline;"
                                    id="maxscore"></h2>
                            </div>
                            <div style="width: fit-content; display: inline; float: right; padding-right: 5px;">
                                <h2
                                    style="font-family: 'Nerko One', cursive; color: #dbdfac; width: fit-content; display: inline;">
                                    Score :
                                </h2>
                                <h2 style="font-family: 'Nerko One', cursive; color: #dbdfac; width: fit-content; display: inline;"
                                    id="score">0</h2>
                            </div>
                        </div>
                        <div class="board" id="board">
                            <button class="field" id="0">
                                <p style="color: #dbdfac;"></p>
                            </button>
                            <button class="field" id="1">
                                <p style="color: #dbdfac;"></p>
                            </button>
                            <button class="field no-r" id="2">
                                <p style="color: #dbdfac;"></p>
                            </button>
                            <button class="field" id="3">
                                <p style="color: #dbdfac;"></p>
                            </button>
                            <button class="field" id="4">
                                <p style="color: #dbdfac;"></p>
                            </button>
                            <button class="field no-r" id="5">
                                <p style="color: #dbdfac;"></p>
                            </button>
                            <button class="field no-b" id="6">
                                <p style="color: #dbdfac;"></p>
                            </button>
                            <button class="field no-b" id="7">
                                <p style="color: #dbdfac;"></p>
                            </button>
                            <button class="field no-b no-r" id="8">
                                <p style="color: #dbdfac;"></p>
                            </button>
                        </div>
                    </div>
                    <div class="card-footer mx-auto">
                        <button class="mx-auto restart" style="padding: 10px 20px; background-color: #d7f171; border: none;
                        border-radius: 20px; color: #2a1e5c; font-size: 20px;
                        font-weight: bold; cursor: pointer; text-transform: uppercase;">Restart</button>
                        <button style="padding: 10px 20px; background-color: #d7f171; border: none;
                        border-radius: 20px; color: #2a1e5c; font-size: 20px; align-self: center;
                        font-weight: bold; cursor: pointer; text-transform: uppercase;" onclick="quit()">Quit</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- End Row-->

{% endblock %}

{% block js %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-dark@3/dark.css">
<script src="//cdn.jsdelivr.net/npm/sweetalert2@10"></script>
<script>
    $('#fulltable').on('click', function () {
        // if already full screen; exit
        // else go fullscreen
        if (
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
        ) {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        } else {
            element = $('#gamecard').get(0);
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }
    });

    var score = 0;
    var maxScore = 0;

    $.ajax({
        url: "/tictactoe/maxscore/",
        type: 'GET',
        data: { 'csrfmiddlewaretoken': '{{ csrf_token }}', 'level': '{{ level }}' },
        datatype: 'json',
        success: function (data) {
            maxScore = data['maxScore'];
            document.getElementById('maxscore').innerText = maxScore;
        },
        error: function () {
            Swal.fire({
                text: "Something went wrong!",
                icon: "error",
            });
        }
    });

    function updateScore() {
        document.getElementById('score').innerText = score;
        if (score > maxScore) {
            maxScore = score;
            document.getElementById('maxscore').innerText = maxScore;
        }
    }

    /**
     * This module stores the game board information
     */

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    const gameBoard = (() => {
        let _board = new Array(9);
        const getField = (num) => _board[num];
        const getFields = () => _board;
        /**
         * Changes the sign of the field to the sign of the player
         * @param {*} num number of field in the array from 0 to 8 sstarting from left top
         * @param {*} player the player who changes the field
         */
        const setField = (num, player) => {
            const htmlField = document.querySelector(`.board button:nth-child(${num + 1}) p`);
            htmlField.classList.add('puff-in-center');
            htmlField.textContent = player.getSign();
            _board[num] = player.getSign();
        }

        const setFieldForAiLogic = (num, player) => {
            if (player == undefined) {
                _board[num] = undefined;
                return;
            }
            _board[num] = player.getSign();
        }

        const getEmptyFieldsIdx = () => {
            fields = [];
            for (let i = 0; i < _board.length; i++) {
                const field = _board[i];
                if (field == undefined) {
                    fields.push(i);
                }
            }
            return fields;
        }

        const clear = () => {
            for (let i = 0; i < _board.length; i++) {
                _board[i] = undefined;
            }
        }
        return {
            getField,
            getFields,
            getEmptyFieldsIdx,
            setField,
            setFieldForAiLogic,
            clear
        };
    })();

    const Player = (sign) => {
        let _sign = sign;
        const getSign = () => _sign;
        const setSign = (sign, active) => {
            _sign = sign;
        }
        return {
            getSign,
            setSign
        }
    }

    const minimaxAiLogic = ((percentage) => {

        let aiPrecision = percentage;

        const setAiPercentage = (percentage) => {
            aiPrecision = percentage;
        }
        const getAiPercentage = () => {
            return aiPrecision;
        }

        /**
         * Chooses the next filed for the AI Player.
         * The AI player has an 'aiPercentage' value, this function chooses the best move proportionate to that value,
         * and chooses a random move the rest of the time.
         * For example if the 'aiPercentage' is 64 then the probability of the best move is 0.64 and the probability of a random move is 0.34
         */
        const chooseField = () => {

            //random number between 0 and 100
            const value = Math.floor(Math.random() * (100 + 1));

            // if the random number is smaller then the ais threshold, it findds the best move
            let choice = null;
            if (value <= aiPrecision) {
                console.log('bestChoice');
                choice = minimax(gameBoard, gameController.getAiPlayer()).index
                const field = gameBoard.getField(choice);
                if (field != undefined) {
                    return "error"
                }
            }
            else {
                console.log('NotbestChoice');
                const emptyFieldsIdx = gameBoard.getEmptyFieldsIdx();
                let noBestMove = Math.floor(Math.random() * emptyFieldsIdx.length);
                choice = emptyFieldsIdx[noBestMove];
            }
            return choice;
        }


        const findBestMove = (moves, player) => {
            let bestMove;
            if (player === gameController.getAiPlayer()) {
                let bestScore = -10000;
                for (let i = 0; i < moves.length; i++) {
                    if (moves[i].score > bestScore) {
                        bestScore = moves[i].score;
                        bestMove = i;
                    }
                }
            } else {
                let bestScore = 10000;
                for (let i = 0; i < moves.length; i++) {
                    if (moves[i].score < bestScore) {
                        bestScore = moves[i].score;
                        bestMove = i;
                    }
                }
            }
            return moves[bestMove];

        }

        /**
         * Returns an object which includes the 'index' and the 'score' of the next best move
         * @param {gameBoard} newBoard - call it with the gameBoard
         * @param {player} player - call it with the AI player
         */
        const minimax = (newBoard, player) => {

            let empty = newBoard.getEmptyFieldsIdx();

            if (gameController.checkForDraw(newBoard)) {
                return {
                    score: 0
                };
            }
            else if (gameController.checkForWin(newBoard)) {

                if (player.getSign() == gameController.getHumanPlayer().getSign()) {
                    return {
                        score: 10
                    };
                }
                else if (player.getSign() == gameController.getAiPlayer().getSign()) {
                    return {
                        score: -10
                    };
                }
            }

            let moves = [];

            for (let i = 0; i < empty.length; i++) {
                let move = {};
                move.index = empty[i];

                //Change the field value to the sign of the player
                newBoard.setFieldForAiLogic(empty[i], player);

                //Call the minimax with the opposite player
                if (player.getSign() == gameController.getAiPlayer().getSign()) {
                    let result = minimax(newBoard, gameController.getHumanPlayer());
                    move.score = result.score;
                }
                else {
                    let result = minimax(newBoard, gameController.getAiPlayer());
                    move.score = result.score;
                }

                //Reset the filed value set before
                newBoard.setFieldForAiLogic(empty[i], undefined);

                moves.push(move);
            }

            //find the best move
            return findBestMove(moves, player);

        }
        return {
            minimax,
            chooseField,
            getAiPercentage,
            setAiPercentage
        }
    })(0);




    const gameController = (() => {
        const _humanPlayer = Player('X');
        const _aiPlayer = Player('O')
        const _aiLogic = minimaxAiLogic;

        const getHumanPlayer = () => _humanPlayer;
        const getAiPlayer = () => _aiPlayer;

        const _sleep = (ms) => {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Checks if a player has filled a row.
         * If someone filled a row it returns true, else it returns false.
         * @param {gameBoard} board - call with the gameBoard
         */
        const _checkForRows = (board) => {
            for (let i = 0; i < 3; i++) {
                let row = []
                for (let j = i * 3; j < i * 3 + 3; j++) {
                    row.push(board.getField(j));
                }

                if (row.every(field => field == 'X') || row.every(field => field == 'O')) {
                    return true;
                }
            }
            return false;
        }

        /**
          * Checks if a player has filled a column.
          * If someone filled a column it returns true, else it returns false.
          * @param {gameBoard} board - call with the gameBoard
          */
        const _checkForColumns = (board) => {
            for (let i = 0; i < 3; i++) {
                let column = []
                for (let j = 0; j < 3; j++) {
                    column.push(board.getField(i + 3 * j));
                }

                if (column.every(field => field == 'X') || column.every(field => field == 'O')) {
                    return true;
                }
            }
            return false;
        }


        /**
         * Checks if a player has filled a diagonal.
         * If someone filled a diagonal it returns true, else it returns false.
         * @param {gameBoard} board - call with the gameBoard
         */
        const _checkForDiagonals = (board) => {
            diagonal1 = [board.getField(0), board.getField(4), board.getField(8)];
            diagonal2 = [board.getField(6), board.getField(4), board.getField(2)];
            if (diagonal1.every(field => field == 'X') || diagonal1.every(field => field == 'O')) {
                return true;
            }
            else if (diagonal2.every(field => field == 'X') || diagonal2.every(field => field == 'O')) {
                return true;
            }
        }

        const checkForWin = (board) => {
            if (_checkForRows(board) || _checkForColumns(board) || _checkForDiagonals(board)) {
                return true;
            }
            return false;
        }

        /**
         * Checks if the game is a draw.
         * If its a draw it returns true, else it returns false.
         * @param {gameBoard} board 
         */
        const checkForDraw = (board) => {
            if (checkForWin(board)) {
                return false;
            }
            for (let i = 0; i < 9; i++) {
                const field = board.getField(i);
                if (field == undefined) {
                    return false;
                }
            }
            return true;
        }

        /**
         * changes the sign of the Human player to 'sing' and the AI players to the other sign.
         * @param {string} sign - 'X' or 'O'
         */
        const changeSign = (sign) => {
            if (sign == 'X') {
                _humanPlayer.setSign('X', true);
                _aiPlayer.setSign('O');
            }
            else if (sign == 'O') {
                _humanPlayer.setSign('O', true);
                _aiPlayer.setSign('X');
            }
            else throw 'Incorrect sign';
        }

        /**
         * Steps the player to the field, and checks if the game has come to an end.
         * If the game if finished it disables the buttons.
         * @param {int} num - the index of the field which the player clicked
         */
        const playerStep = (num) => {
            const field = gameBoard.getField(num);
            if (field == undefined) {
                gameBoard.setField(num, _humanPlayer);
                if (checkForWin(gameBoard)) {
                    (async () => {
                        await _sleep(500 + (Math.random() * 500));
                        endGame(_humanPlayer.getSign());
                    })();
                }
                else if (checkForDraw(gameBoard)) {
                    (async () => {
                        await _sleep(500 + (Math.random() * 500));
                        endGame("Draw");
                    })();
                }
                else {
                    displayController.deactivate();
                    (async () => {
                        await _sleep(250 + (Math.random() * 300));
                        aiStep();
                        if (!checkForWin(gameBoard)) {
                            displayController.activate();
                        }
                    })();
                }
            }
            else {
                console.log('Already Filled')
            }
        }


        /**
         * 
         * @param {*} sign 
         */
        const endGame = async function (sign) {

            const card = document.querySelector('.card');
            console.log('deactivate');
            displayController.deactivate();
            displayController.makeBodyRestart();

            if (sign == "Draw") {
                console.log("Its a draw");
                if (
                    document.fullscreenElement ||
                    document.webkitFullscreenElement ||
                    document.mozFullScreenElement ||
                    document.msFullscreenElement
                ) {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
                Swal.fire({
                    title: "Its a draw!",
                    text: "Want to play again?",
                    icon: "warning",
                    showCancelButton: true,
                }).then((play) => {
                    if (play.isConfirmed) {
                        gameController.restart();
                    } else {
                        window.location = '/tictactoe/'
                    }
                });
            }
            else {
                console.log(`The winner is player ${sign}`);
                if (gameController.getHumanPlayer().getSign() == sign) {
                    console.log("user won");
                    if (
                        document.fullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement
                    ) {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        }
                    }
                    score += 1;
                    updateScore();
                    var boxes = playerWon();
                    await sleep(2000);
                    Swal.fire({
                        title: "Congratulation! You Won!",
                        text: "Want to play again?",
                        icon: "success",
                        confirmButtonText: "Yes, Play",
                        showCancelButton: true,
                        cancelButtonText: "No",
                    }).then((play) => {
                        if (play.isConfirmed) {
                            document.getElementsByClassName('field')[boxes[0]].classList.remove('win');
                            document.getElementsByClassName('field')[boxes[1]].classList.remove('win');
                            document.getElementsByClassName('field')[boxes[2]].classList.remove('win');
                            gameController.restart();

                        } else {
                            window.location = '/tictactoe/'
                        }
                    });
                } else {
                    console.log("user lost");
                    if (
                        document.fullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement
                    ) {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        }
                    }
                    // post data as lost
                    score = 0;
                    updateScore();
                    Swal.fire({
                        title: "You Lost!",
                        text: "Want to play again?",
                        icon: "warning",
                        confirmButtonText: "Yes, Play",
                        showCancelButton: true,
                        cancelButtonText: "No",
                    }).then((play) => {
                        if (play.isConfirmed) {
                            gameController.restart();
                        } else {
                            window.location = '/tictactoe/'
                        }
                    });
                }
            }
        }

        /**
         * Steps the AI.
         */
        const aiStep = () => {
            const num = _aiLogic.chooseField();
            gameBoard.setField(num, _aiPlayer);
            if (checkForWin(gameBoard)) {
                (async () => {
                    await _sleep(500 + (Math.random() * 500));
                    endGame(_aiPlayer.getSign())
                })();

            }
            else if (checkForDraw(gameBoard)) {
                (async () => {
                    await _sleep(500 + (Math.random() * 500));
                    endGame("Draw");
                })();
            }
        }

        /**
         * Restarts the game.
         */
        const restart = async function () {

            const card = document.querySelector('.card');

            gameBoard.clear();
            displayController.clear();
            if (_humanPlayer.getSign() == 'O') {
                aiStep();
            }
            console.log('restart');
            console.log(minimaxAiLogic.getAiPercentage());
            displayController.activate();

            document.body.removeEventListener('click', gameController.restart);

        }

        return {
            getHumanPlayer,
            getAiPlayer,
            checkForWin,
            checkForDraw,
            changeSign,
            playerStep,
            endGame,
            restart
        }
    })();

    const displayController = (() => {
        const htmlBoard = Array.from(document.querySelectorAll('button.field'));
        const restart = document.querySelector('.restart');
        const x = document.querySelector('.x');
        const o = document.querySelector('.o');

        const _changeAI = () => {
            const value = '{{ level }}';
            if (value == 'easy') {
                minimaxAiLogic.setAiPercentage(25);
            }
            else if (value == 'medium') {
                minimaxAiLogic.setAiPercentage(62);
            }
            else if (value == 'hard') {
                minimaxAiLogic.setAiPercentage(81);
            }
            else if (value == 'unbeatable') {
                minimaxAiLogic.setAiPercentage(90);
            }
            gameController.restart();
        }

        const clear = () => {
            htmlBoard.forEach(field => {
                const p = field.childNodes[1];
                p.classList = [];
                p.textContent = '';
            });
        }


        const deactivate = () => {
            htmlBoard.forEach(field => {
                field.setAttribute('disabled', '');
            });
        }

        const activate = () => {
            htmlBoard.forEach(field => {
                field.removeAttribute('disabled');
            });
        }

        const makeBodyRestart = () => {
            const body = document.querySelector('body');
            body.addEventListener('click', gameController.restart);

        }

        const _init = (() => {
            for (let i = 0; i < htmlBoard.length; i++) {
                field = htmlBoard[i];
                field.addEventListener('click', gameController.playerStep.bind(field, i));
            }

            restart.addEventListener('click', function () {
                if (gameBoard.getFields().includes(gameController.getHumanPlayer().getSign()) || score > 0) {
                    if (
                        document.fullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement
                    ) {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        }
                    }
                    Swal.fire({
                        title: "Are you sure?",
                        text: "Want to restart? Your score will be lost!",
                        icon: "warning",
                        confirmButtonText: "Restart",
                        showCancelButton: true,
                    }).then((restart) => {
                        if (restart.isConfirmed) {
                            score = 0;
                            updateScore();
                            gameController.restart();
                        }
                    });
                }
            });
            $(document).ready(function () {
                _changeAI();
            });
        })();

        return {
            deactivate,
            activate,
            clear,
            makeBodyRestart
        }
    })();

    // To highlight the box at start
    gameController.changeSign('{{ player_sign }}');

    const winningConditions = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],
        [2, 4, 6]
    ];

    function playerWon() {
        const mainBoard = gameBoard.getFields();
        for (let i = 0; i < winningConditions.length; i++) {
            var a = mainBoard[winningConditions[i][0]];
            var b = mainBoard[winningConditions[i][1]];
            var c = mainBoard[winningConditions[i][2]];
            if (a != 0 && a == b && b == c) {
                const fields = document.getElementsByClassName('field');
                fields[winningConditions[i][0]].classList.add('win');
                fields[winningConditions[i][1]].classList.add('win');
                fields[winningConditions[i][2]].classList.add('win');
                return winningConditions[i];
            }
        }
    }

    function quit() {
        if (gameBoard.getFields().includes(gameController.getHumanPlayer().getSign()) || score > 0) {
            if (
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement
            ) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
            Swal.fire({
                title: "Are you sure?",
                text: "Want to quit?",
                icon: "warning",
                confirmButtonText: "Save & Quit",
                showCancelButton: true,
                cancelButtonText: "Don't Quit",
            }).then((quit) => {
                if (quit.isConfirmed) {
                    window.location = '/tictactoe/';
                }
            });
        } else {
            window.location = '/tictactoe/';
        }
    }

    window.onbeforeunload = function () {
        // before leaving the page save all data
        // post maxScore
        $.ajax({
            url: "/tictactoe/maxscore/",
            type: 'POST',
            data: { 'csrfmiddlewaretoken': '{{ csrf_token }}', 'level': '{{ level }}', 'maxScore': maxScore },
            datatype: 'json',
            success: function (data) {
                console.log(data);
            },
            error: function () {
                Swal.fire({
                    text: "Something went wrong!",
                    icon: "error",
                });
            }
        });
    };

</script>
{% endblock %}